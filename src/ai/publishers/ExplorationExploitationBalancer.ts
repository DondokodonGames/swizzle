/**
 * ExplorationExploitationBalancer
 * æ¢ç´¢ãƒ»æ´»ç”¨ãƒãƒ©ãƒ³ã‚¹èª¿æ•´ã‚·ã‚¹ãƒ†ãƒ 
 * 
 * Phase H Day 4-5: è‡ªå‹•å…¬é–‹ã‚·ã‚¹ãƒ†ãƒ 
 * - Îµ-greedyæˆ¦ç•¥ã«ã‚ˆã‚‹æ¢ç´¢ãƒ»æ´»ç”¨ãƒãƒ©ãƒ³ã‚¹
 * - å‹•çš„æ¢ç´¢ç‡èª¿æ•´
 * - ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªå¤šæ§˜æ€§ç¶­æŒ
 * - å­¦ç¿’ãƒ»é©å¿œãƒ¡ã‚«ãƒ‹ã‚ºãƒ 
 */

import { GeneratedGame, GameGenre, GameMechanic } from '../types/GenerationTypes';

/**
 * ç”Ÿæˆãƒ¢ãƒ¼ãƒ‰
 */
export type GenerationMode = 'exploration' | 'exploitation' | 'balanced';

/**
 * æ¢ç´¢æˆ¦ç•¥
 */
export interface ExplorationStrategy {
  targetGenre?: GameGenre;
  targetMechanic?: GameMechanic;
  targetComplexity?: number;
  targetPlayTime?: number;
  avoidSimilar: boolean;
  experimentalFeatures: boolean;
}

/**
 * ãƒãƒ©ãƒ³ã‚¹èª¿æ•´ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
 */
export interface BalanceParameters {
  diversityScore: number;
  userSatisfaction: number;
  recentPerformance: number;
  portfolioSize: number;
}

/**
 * ãƒãƒ©ãƒ³ã‚µãƒ¼çµ±è¨ˆ
 */
export interface BalancerStatistics {
  totalDecisions: number;
  explorationCount: number;
  exploitationCount: number;
  currentExplorationRate: number;
  averageDiversity: number;
  averageSuccess: number;
}

/**
 * ExplorationExploitationBalancer
 * æ¢ç´¢ãƒ»æ´»ç”¨ã®ãƒãƒ©ãƒ³ã‚¹ã‚’å‹•çš„ã«èª¿æ•´
 */
export class ExplorationExploitationBalancer {
  // æ¢ç´¢ç‡ï¼ˆÎµï¼‰
  public explorationRate: number;
  
  // æœ€å°ãƒ»æœ€å¤§æ¢ç´¢ç‡
  private readonly MIN_EXPLORATION_RATE = 0.1;  // 10%
  private readonly MAX_EXPLORATION_RATE = 0.5;  // 50%
  
  // çµ±è¨ˆæƒ…å ±
  private totalDecisions: number = 0;
  private explorationCount: number = 0;
  private exploitationCount: number = 0;
  private recentDiversity: number[] = [];
  private recentSuccess: number[] = [];
  
  // å­¦ç¿’ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
  private readonly DIVERSITY_WEIGHT = 0.4;
  private readonly SATISFACTION_WEIGHT = 0.3;
  private readonly PERFORMANCE_WEIGHT = 0.3;
  
  constructor(initialExplorationRate: number = 0.3) {
    this.explorationRate = this.clampExplorationRate(initialExplorationRate);
  }
  
  /**
   * æ¬¡ã®ç”Ÿæˆãƒ¢ãƒ¼ãƒ‰ã‚’æ±ºå®š
   */
  decideGenerationMode(): GenerationMode {
    
    this.totalDecisions++;
    
    // Îµ-greedyæˆ¦ç•¥
    const random = Math.random();
    
    if (random < this.explorationRate) {
      // æ¢ç´¢ãƒ¢ãƒ¼ãƒ‰
      this.explorationCount++;
      console.log(`  ğŸ” Generation Mode: EXPLORATION (${(this.explorationRate * 100).toFixed(0)}%)`);
      return 'exploration';
    } else {
      // æ´»ç”¨ãƒ¢ãƒ¼ãƒ‰
      this.exploitationCount++;
      console.log(`  ğŸ¯ Generation Mode: EXPLOITATION (${((1 - this.explorationRate) * 100).toFixed(0)}%)`);
      return 'exploitation';
    }
  }
  
  /**
   * æ¢ç´¢æˆ¦ç•¥ã®ç”Ÿæˆ
   * æœªé–‹æ‹“é ˜åŸŸã‚’ç‰¹å®šã—ã¦æ¢ç´¢æ–¹å‘ã‚’ææ¡ˆ
   */
  generateExplorationStrategy(
    existingGames: GeneratedGame[]
  ): ExplorationStrategy {
    
    // 1. ã‚¸ãƒ£ãƒ³ãƒ«ãƒ»ãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹ã®åˆ†å¸ƒã‚’åˆ†æ
    const genreDistribution = this.analyzeGenreDistribution(existingGames);
    const mechanicDistribution = this.analyzeMechanicDistribution(existingGames);
    
    // 2. æœ€ã‚‚å°‘ãªã„ã‚¸ãƒ£ãƒ³ãƒ«ã‚’ç‰¹å®š
    const leastCommonGenre = this.findLeastCommon(genreDistribution);
    
    // 3. æœ€ã‚‚å°‘ãªã„ãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹ã‚’ç‰¹å®š
    const leastCommonMechanic = this.findLeastCommon(mechanicDistribution);
    
    // 4. è¤‡é›‘åº¦ã®ç©ºç™½ã‚’ç‰¹å®š
    const complexityGap = this.findComplexityGap(existingGames);
    
    return {
      targetGenre: leastCommonGenre as GameGenre,
      targetMechanic: leastCommonMechanic as GameMechanic,
      targetComplexity: complexityGap,
      avoidSimilar: true,
      experimentalFeatures: Math.random() < 0.3 // 30%ã§å®Ÿé¨“çš„æ©Ÿèƒ½ã‚’è©¦ã™
    };
  }
  
  /**
   * æ¢ç´¢ç‡ã®å‹•çš„èª¿æ•´
   */
  adjustExplorationRate(params: BalanceParameters): void {
    
    // 1. å¤šæ§˜æ€§ã‚¹ã‚³ã‚¢ã«åŸºã¥ãèª¿æ•´
    let adjustment = 0;
    
    if (params.diversityScore < 0.5) {
      // å¤šæ§˜æ€§ãŒä½ã„ â†’ æ¢ç´¢ç‡ã‚’ä¸Šã’ã‚‹
      adjustment += 0.05;
    } else if (params.diversityScore > 0.8) {
      // å¤šæ§˜æ€§ãŒé«˜ã„ â†’ æ¢ç´¢ç‡ã‚’ä¸‹ã’ã‚‹
      adjustment -= 0.05;
    }
    
    // 2. ãƒ¦ãƒ¼ã‚¶ãƒ¼æº€è¶³åº¦ã«åŸºã¥ãèª¿æ•´
    if (params.userSatisfaction < 0.7) {
      // æº€è¶³åº¦ãŒä½ã„ â†’ æ´»ç”¨ç‡ã‚’ä¸Šã’ã‚‹ï¼ˆæ¢ç´¢ç‡ã‚’ä¸‹ã’ã‚‹ï¼‰
      adjustment -= 0.03;
    } else if (params.userSatisfaction > 0.9) {
      // æº€è¶³åº¦ãŒé«˜ã„ â†’ æ¢ç´¢ç‡ã‚’ä¸Šã’ã‚‹
      adjustment += 0.02;
    }
    
    // 3. æœ€è¿‘ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã«åŸºã¥ãèª¿æ•´
    if (params.recentPerformance < 0.3) {
      // æˆåŠŸç‡ãŒä½ã„ â†’ æ´»ç”¨ç‡ã‚’ä¸Šã’ã‚‹
      adjustment -= 0.03;
    }
    
    // 4. ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªã‚µã‚¤ã‚ºã«åŸºã¥ãèª¿æ•´
    if (params.portfolioSize < 100) {
      // åˆæœŸæ®µéš â†’ é«˜ã‚ã®æ¢ç´¢ç‡
      adjustment += 0.05;
    } else if (params.portfolioSize > 1000) {
      // æˆç†ŸæœŸ â†’ ä½ã‚ã®æ¢ç´¢ç‡
      adjustment -= 0.05;
    }
    
    // 5. æ¢ç´¢ç‡ã‚’æ›´æ–°
    const oldRate = this.explorationRate;
    this.explorationRate = this.clampExplorationRate(this.explorationRate + adjustment);
    
    if (oldRate !== this.explorationRate) {
      console.log(`  ğŸ“Š Exploration rate adjusted: ${(oldRate * 100).toFixed(0)}% â†’ ${(this.explorationRate * 100).toFixed(0)}%`);
    }
    
    // 6. çµ±è¨ˆã‚’è¨˜éŒ²
    this.recentDiversity.push(params.diversityScore);
    this.recentSuccess.push(params.recentPerformance);
    
    // æœ€æ–°100ä»¶ã®ã¿ä¿æŒ
    if (this.recentDiversity.length > 100) {
      this.recentDiversity.shift();
    }
    if (this.recentSuccess.length > 100) {
      this.recentSuccess.shift();
    }
  }
  
  /**
   * çµ±è¨ˆæƒ…å ±ã®å–å¾—
   */
  getStatistics(): BalancerStatistics {
    
    const averageDiversity = this.recentDiversity.length > 0
      ? this.recentDiversity.reduce((sum, d) => sum + d, 0) / this.recentDiversity.length
      : 0;
    
    const averageSuccess = this.recentSuccess.length > 0
      ? this.recentSuccess.reduce((sum, s) => sum + s, 0) / this.recentSuccess.length
      : 0;
    
    return {
      totalDecisions: this.totalDecisions,
      explorationCount: this.explorationCount,
      exploitationCount: this.exploitationCount,
      currentExplorationRate: this.explorationRate,
      averageDiversity,
      averageSuccess
    };
  }
  
  /**
   * çµ±è¨ˆãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ
   */
  generateReport(): string {
    
    const stats = this.getStatistics();
    
    const explorationPercentage = stats.totalDecisions > 0
      ? (stats.explorationCount / stats.totalDecisions * 100).toFixed(1)
      : '0.0';
    
    const exploitationPercentage = stats.totalDecisions > 0
      ? (stats.exploitationCount / stats.totalDecisions * 100).toFixed(1)
      : '0.0';
    
    return `
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š Exploration-Exploitation Balance Report
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Total Decisions: ${stats.totalDecisions}
  â”œâ”€ Exploration: ${stats.explorationCount} (${explorationPercentage}%)
  â””â”€ Exploitation: ${stats.exploitationCount} (${exploitationPercentage}%)

Current Exploration Rate: ${(stats.currentExplorationRate * 100).toFixed(0)}%

Recent Performance:
  â”œâ”€ Avg Diversity: ${(stats.averageDiversity * 100).toFixed(1)}%
  â””â”€ Avg Success: ${(stats.averageSuccess * 100).toFixed(1)}%

Status: ${this.getBalanceStatus(stats)}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    `.trim();
  }
  
  /**
   * ãƒãƒ©ãƒ³ã‚¹çŠ¶æ…‹ã®è©•ä¾¡
   */
  private getBalanceStatus(stats: BalancerStatistics): string {
    
    if (stats.averageDiversity > 0.7 && stats.averageSuccess > 0.3) {
      return 'âœ… Excellent - High diversity & success';
    } else if (stats.averageDiversity > 0.5 && stats.averageSuccess > 0.25) {
      return 'âœ“ Good - Balanced exploration';
    } else if (stats.averageDiversity < 0.4) {
      return 'âš ï¸ Warning - Low diversity, increase exploration';
    } else if (stats.averageSuccess < 0.2) {
      return 'âš ï¸ Warning - Low success, increase exploitation';
    } else {
      return 'â—‹ Fair - Adjustment needed';
    }
  }
  
  /**
   * ã‚¸ãƒ£ãƒ³ãƒ«åˆ†å¸ƒã®åˆ†æ
   */
  private analyzeGenreDistribution(
    games: GeneratedGame[]
  ): Record<string, number> {
    
    const distribution: Record<string, number> = {};
    
    for (const game of games) {
      const genre = game.metadata.spec.concept.genre;
      distribution[genre] = (distribution[genre] || 0) + 1;
    }
    
    return distribution;
  }
  
  /**
   * ãƒ¡ã‚«ãƒ‹ã‚¯ã‚¹åˆ†å¸ƒã®åˆ†æ
   */
  private analyzeMechanicDistribution(
    games: GeneratedGame[]
  ): Record<string, number> {
    
    const distribution: Record<string, number> = {};
    
    for (const game of games) {
      const mechanic = game.metadata.spec.concept.mechanic;
      distribution[mechanic] = (distribution[mechanic] || 0) + 1;
    }
    
    return distribution;
  }
  
  /**
   * æœ€ã‚‚å°‘ãªã„è¦ç´ ã‚’æ¤œå‡º
   */
  private findLeastCommon(
    distribution: Record<string, number>
  ): string | undefined {
    
    if (Object.keys(distribution).length === 0) {
      return undefined;
    }
    
    let leastCommon: string | undefined;
    let minCount = Infinity;
    
    for (const [key, count] of Object.entries(distribution)) {
      if (count < minCount) {
        minCount = count;
        leastCommon = key;
      }
    }
    
    return leastCommon;
  }
  
  /**
   * è¤‡é›‘åº¦ã®ç©ºç™½ã‚’æ¤œå‡º
   */
  private findComplexityGap(games: GeneratedGame[]): number {
    
    // è¤‡é›‘åº¦ã®ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ ã‚’ä½œæˆï¼ˆ0-1ã‚’10åŒºé–“ã«åˆ†å‰²ï¼‰
    const bins = Array(10).fill(0);
    
    for (const game of games) {
      const complexity = game.vector.rules.ruleCount; // 0-1ã®å€¤
      const binIndex = Math.floor(complexity * 10);
      const clampedIndex = Math.min(9, Math.max(0, binIndex));
      bins[clampedIndex]++;
    }
    
    // æœ€ã‚‚å°‘ãªã„åŒºé–“ã‚’ç‰¹å®š
    let minBinIndex = 0;
    let minCount = bins[0];
    
    for (let i = 1; i < bins.length; i++) {
      if (bins[i] < minCount) {
        minCount = bins[i];
        minBinIndex = i;
      }
    }
    
    // åŒºé–“ã®ä¸­å¤®å€¤ã‚’è¿”ã™
    return (minBinIndex + 0.5) / 10;
  }
  
  /**
   * æ¢ç´¢ç‡ã®ç¯„å›²åˆ¶é™
   */
  private clampExplorationRate(rate: number): number {
    return Math.max(
      this.MIN_EXPLORATION_RATE,
      Math.min(this.MAX_EXPLORATION_RATE, rate)
    );
  }
  
  /**
   * ãƒªã‚»ãƒƒãƒˆ
   */
  reset(): void {
    this.explorationRate = 0.3;
    this.totalDecisions = 0;
    this.explorationCount = 0;
    this.exploitationCount = 0;
    this.recentDiversity = [];
    this.recentSuccess = [];
  }
}